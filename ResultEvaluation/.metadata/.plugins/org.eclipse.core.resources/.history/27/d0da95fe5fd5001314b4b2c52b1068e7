/*
 * def.cpp
 *
 *  Created on: May 5, 2014
 *      Author: yqian33
 */
#include "def.h"

int buildComplexMap(string infile, map <int, string> & proMap)
{
	ifstream input;
	input.open(infile.c_str());
	if (!input.is_open())
	{
		cout <<"Open File"<<infile<<" Error"<<endl;
		return 0;
	}
	string line;
	unsigned int pid = 0;
	string protein="start";
	while ( getline(input, line))
	{

		vector<string> strsplit = split(line, pattern);
		unsigned int cid = atoi(strsplit[0].c_str());

		string pro = strsplit[1];
		//cout << "pro: "<<pro << endl;
		if( pid != cid)//write a new protein
		{
			//cout << protein << endl;
			proMap[pid]=protein;
			//protein = " ";
			//protein.append("\t"+pro);
			protein=pro;
		}
		else
		{
			protein.append(" "+pro);
		}
		pid = cid;
	}
	input.close();

	return 1;

}

int buildSolMap(string infile, map <int, string> & proMap)
{
	ifstream input;
	input.open(infile.c_str());
	if (!input.is_open())
	{
		cout <<"Open File"<<infile<<" Error"<<endl;
		return 0;
	}
	string line;
	int sol_num=0;
	string protein="";
	while ( getline(input, line))
	{
		vector<string> strsplit = split(line, pattern);

		for(unsigned int i=0; i<strsplit.size(); i++)
		{
			vector<string> proName = split(strsplit[i], "/");
			protein += proName[0]+" ";
		}

		proMap[sol_num++]=protein;
		//cout << sol_num-1 << " "<< protein << endl;
		protein="";

	}
	input.close();

	return 1;
}
/*
 * consistent with the result in known_complexes_overlap/single_PPIs/AlignMCL_overlap.txt
 */
int overlap(string infile, map <int, string> & proMap, string outfile)
{
	ifstream input;
	ofstream output;
	output.open(outfile.c_str());

	input.open(infile.c_str());
	if( !input.is_open())
	{
		cout <<"Open File"<<infile<<" Error"<<endl;
		return 0;
	}

	string line;
	int line_count=0;
	int sol_count=0;
	int highsol_count=0;
	int highersol_count=0;

	while ( getline(input, line))
	{
		bool flag=false;
		bool score_flag=false;
		bool highscore_flag=false;

		line_count++;
		string spe_pro="";
		vector<string> pro_pair = split(line, pattern);
		for(unsigned int i=0; i<pro_pair.size(); i++)
		{
			vector<string> single_pair= split(pro_pair[i], "/");//single_pair[] decide the first spec or the second spec
			if (notExist(single_pair[1], spe_pro))
			{
				spe_pro.append(single_pair[1]+" ");
			}
		}
		//repeat mask spe_pro
		//cout << spe_pro << endl;
		//int TP_count=0;
		map<int, string>::iterator it = proMap.begin();
		it++;

		int TP_count=0;

		vector<string> query = split(spe_pro, " ");
		for(; it != proMap.end(); it++)
		{
			vector<string> subject = split(it->second, " ");

			if (subject.size()>4)
			{
			for(unsigned int i=0; i<query.size()-1; i++)
			{
				for(unsigned int j=0; j<subject.size(); j++)
				{
					//cout << query[i] << " " << subject[j] << endl;
					if (query[i] == subject[j])
					{
						TP_count++;
					}
				}
			}
			//pi, ro, F-index
			if (TP_count!=0)
			{
				double pi = (double)TP_count/(query.size()-1);
				double ro = (double)TP_count/subject.size();
				double f_score = (double)2*pi*ro/(pi+ro);
				//cout << f_score << endl;
				if (f_score - 0.3 >0)
				{
					//g_count ++;
					score_flag = true;
				}
				if (f_score - 0.5 >0)
				{
					highscore_flag = true;
				}
				else
				{
					//l_count++;
				}
				//id in So:line_count  id in known complex: it->first

				output << line_count << " " << it->first << " " << f_score<< " "<< query.size()-1 << " " <<subject.size()<< " " << TP_count<< endl;
				flag=true;

				//cout << l_count << " " << g_count << endl;
			}
			}
			TP_count = 0;
		}

		if (flag)
		{
			sol_count++;
		}
		if (score_flag)
		{
			highsol_count++;
		}
		if (highscore_flag)
		{
			highersol_count++;
		}
	}
	cout << "Matched solutions:"<< sol_count<<endl;
	cout << "High quality solutions(F-index > 0.3):"<< highsol_count<<endl;
	cout << "High quality solutions(F-index > 0.5):"<< highersol_count<<endl;
	input.close();
	output.close();
	return 1;
}

/*
 * consistent with the result in known_complexes_overlap/single_PPIs/AlignMCL_overlap.txt
 * infile is known complexes file.
 */
int overlap_clean(map <int, string> & proMap, map <int, string> & complexMap, string outfile)
{
	ofstream output;
	output.open(outfile.c_str());

	//for every complex , search matched sols
	map<int, string>::iterator comp_it = complexMap.begin();
	comp_it++;
	for(; comp_it != complexMap.end(); comp_it++)
	{
		cout << comp_it->second<< endl;
		int proId, proNum;
		int complexId = comp_it ->first;
		int complexNum = complexMap.size();
		double f_score=0.00;

		//proteins in comp_it->second;
		map<int, string>::iterator pro_it = proMap.begin();
		for(; pro_it != proMap.end(); pro_it++)
		{
			double rawf = F_index(comp_it->second, pro_it->second);
			if( rawf-f_score >0)
			{
				f_score = rawf;
				proId = pro_it->first;
				proNum = proMap.size();
			}
		}
		//
		output << complexId << " " << proId << " " << complexNum << " " <<  proNum << " "<< f_score << endl;
	}

	//cout << "Matched solutions:"<< sol_count<<endl;
	//cout << "High quality solutions(F-index > 0.3):"<< highsol_count<<endl;
	//cout << "High quality solutions(F-index > 0.5):"<< highersol_count<<endl;

	output.close();
	return 1;
}
double F_index(string str1, string str2)
{
	double fscore=0.00;
	vector<string> str1_item = split(str1, " ");
	vector<string> str2_item = split(str2, " ");
	int count=0;
	for(unsigned int i=0; i<str2_item.size(); i++)
	{
		for(unsigned int j=0; j<str1_item.size(); j++)
		{
			if (str2_item[i]== str1_item[j])
			{
				count++;
			}
		}
	}

	if (count != 0)
	{
		double pi = (double)count/(str2_item.size());
		double ro = (double)count/str1_item.size();
		fscore = (double)2*pi*ro/(pi+ro);
	}
	return fscore;
}

bool notExist(string single_pair, string spe_pro)
{
	bool flag = true;
    vector<string> str = split(spe_pro, " ");
    for (unsigned int i=0; i<str.size(); i++)
    {
    	if(single_pair == str[i])
    	{
    		flag = false;
    	}
    }
	return flag;

}

int find_overlap(string spe_pro, map <int, string> & proMap)
{
	int count=0;

	map<int, string>::iterator it = proMap.begin();
	it++;
	for(; it != proMap.end(); it++)
	{
		vector<string> subject = split(it->second, " ");
		vector<string> query = split(spe_pro, " ");
		for(int i=0; i<query.size(); i++)
		{
			for(int j=0; j<subject.size(); j++)
			{
				if (query[i] == subject [j])
				{
					count++;

				}
			}
		}

	}
	return count;

}

void clean_overlap(string infile)
{
	ifstream input;
	input.open(infile.c_str());

	string line;
	while( getline(input, line))
	{
		vector<string> str = split(line, " ");
		//str[1] as key, line as value
		//string value = str[0]+
	}
}
void printMap(map <int, string> & proMap)
{
	map<int, string>::iterator it = proMap.begin();
	for(; it != proMap.end(); it++)
	{
		cout<<it->first<<'\t'<<it->second<<endl;
	}
}

vector<string> split(string str, string pattern)
{
     string::size_type pos;
     vector<string> result;
     str+=pattern;//扩展字符串以方便操作
     int size=str.size();

     for(int i=0; i<size; i++)
     {
         pos=str.find(pattern,i);
         if(pos<size)
         {
             string s=str.substr(i,pos-i);
             result.push_back(s);
             i=pos+pattern.size()-1;
         }
     }
     return result;
}
